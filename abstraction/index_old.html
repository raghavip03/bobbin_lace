</style>
</head>
<body>
  <h1>Bobbin Lace Generator</h1>
  <label>Number of Initial Pins: <input type="number" id="pins" min="2" step="1" value="2"></label>
  <label>Number of Rows: <input type="number" id="rows" min="2" value="2"></label>
  <button onclick="generateLace()">Generate Lace</button>
  <canvas id="laceCanvas" width="600" height="800"></canvas>
  <script>
const canvas = document.getElementById('laceCanvas');
const ctx = canvas.getContext('2d');
const startX = 50;
const startY = 50;
const spacingX = 60;
const spacingY = 100;

//array of colors and assign to each thread? somehow

//Draws the grid with the pins offset for odd
function drawGrid(pinCount, rowCount, spacingX, spacingY) {
    ctx.strokeStyle = '#ddd';
    ctx.fillStyle = '#000';

    for (let j = 0; j <= rowCount; j++) {
        let shiftX = (j % 2) * (spacingX / 2);
        let count = j % 2 === 1 ? pinCount - 1 : pinCount;

        for (let i = 0; i < count; i++) {
            let x = startX + i * spacingX + shiftX;
            let y = startY + j * spacingY;

            ctx.beginPath();
            ctx.arc(x, y, 4, 0, Math.PI * 2);
            ctx.fill();
        }
    }
}

//Draws curvers based on a control coordinate to mimic lace style
//path: list of points define ONE bezier curve
// = [start (x,y), control1, control2, end] these are the start end and the control points used by bezier curve
function bezierPath(path, color) {
  ctx.strokeStyle = color;
  ctx.beginPath();

  //loops through each point in path can be [start, c1, end] or [start, c1, c2, end]
  for (let i = 0; i < path.length; i++) {
    let segment = path[i];
    //let j = 0;
    //moveTo moves our cursor before drawing to the start point (x,y)
    if (i == 0) {
      start = segment[0];
      ctx.moveTo(start[0], start[1]);
      //j++;
    }
    let c1 = segment[1]; //control 1
    let c2 = c1;
    if (segment.length > 3) {
      c2 = segment[2]; // control 2 if it exists
    }
    let end = segment[segment.length - 1]; // assign end point

    // draws curve from starting point in moveTo to the end point using control points
    ctx.bezierCurveTo(c1[0], c1[1], c2[0], c2[1], end[0], end[1])
  }
  ctx.stroke()
}

// braid is an array, where each element can be either an integer or another array of two elements
// in case it is an array of two elements, it is a twist where two pairs of threads are intersected at the same time
// Allowed values in the braid are: -1, 2, -3. Twist is [-1, -3] concurrently

// braid = [-1, 2, [-1,-3], -1, 2, [-1,-3] ]
// pin is an array with 2 coordinates of a pin
function drawBraid(pin, braid, color) {
    //the first pin's x & y positions
    dx = pin[0] - spacingX / 4 + 29;
    dy = pin[1] + spacingY / 6;

    ory = spacingY / braid.length - spacingY/6; //vertical spacing between rows in braid
    nx = spacingX / 6; // horizontal spacing between threads
    op = 0.05; //offset to create over and under effects

    for (let i = 0; i < braid.length; i++) {

        //each braid instruction either [-1] or [-1, -3]
        let m = braid[i];
        if (!Array.isArray(m)) {
            m = [m];
        }
        //i = stitch, j = thread stitch will be applied to
        for (let j = 0; j < 4; j++) {
            if (m.includes(j+1)) { //if current threads needs to move right
                bezierPath([
                    [
                        [dx+j*nx, dy+i*ory],
                        [dx+j*nx, dy+ory*(i+0.25)],
                        [dx+nx*(j+0.5), dy+ory*(i+0.5)]
                    ], [
                        [dx+nx*(j+1), dy+ory*(i+0.75)],
                        [dx+nx*(j+1), dy+ory*(i+1)]
                    ]
                ], "blue");
            } else if (m.includes(j)) {
                bezierPath([
                    [
                        [dx+nx*j, dy+ory*i],
                        [dx+nx*j, dy+ory*(i+0.25)],
                        [dx+nx*(j-0.5+4*op), dy+ory*(i+0.5-2*op)],
                        [dx+nx*(j-0.5+2*op), dy+ory*(i+0.5-op)]
                    ]
                ], "green");
                bezierPath([
                    [
                        [dx+nx*(j-0.5-2*op), dy+ory*(i+0.5+op)],
                        [dx+nx*(j-0.5-4*op), dy+ory*(i+0.5+2*op)],
                        [dx+nx*(j-1), dy+ory*(i+0.75)],
                        [dx+nx*(j-1), dy+ory*(i+1)]
                    ]
                ], "black");
            } else if (m.includes(-(j+1))) {
                bezierPath([
                    [
                        [dx+nx*j, dy+ory*i],
                        [dx+nx*j, dy+ory*(i+0.25)],
                        [dx+nx*(j+0.5-4*op), dy+ory*(i+0.5-2*op)],
                        [dx+nx*(j+0.5-2*op), dy+ory*(i+0.5-op)]
                    ]
                ], "red");
                bezierPath([
                    [
                        [dx+nx*(j+0.5+2*op), dy+ory*(i+0.5+op)],
                        [dx+nx*(j+0.5+4*op), dy+ory*(i+0.5+2*op)],
                        [dx+nx*(j+1), dy+ory*(i+0.75)],
                        [dx+nx*(j+1), dy+ory*(i+1)]
                    ]
                ], "blue");
            } else if (m.includes(-j)) {
                bezierPath([
                    [
                        [dx+nx*j, dy+ory*i],
                        [dx+nx*j, dy+ory*(i+0.25)],
                        [dx+nx*(j-0.5), dy+ory*(i+0.5)]
                    ], [
                        [dx+nx*(j-1), dy+ory*(i+0.75)],
                        [dx+nx*(j-1), dy+ory*(i+1)]
                    ]
                ], color);
            }
            else {
                bezierPath([
                    [
                        [dx+nx*j, dy+ory*i],
                        [dx+nx*j, dy+ory*(i+1)]
                    ]
                ], color);  // Just a line
            }
        }
    }
}

window.onload = function () {
  document.querySelector("button").onclick = generateLace;
function generateLace() {
    //user inputs and canvas
    const pinCount = parseInt(document.getElementById('pins').value);
    const rowCount = parseInt(document.getElementById('rows').value);
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    //draws the pin grid
    drawGrid(pinCount, rowCount, spacingX, spacingY);

    for (let j = 0; j <= rowCount; j++) {
        //sets up positions for the top and bottom 4 parallel threads
        let dx = spacingX / 4 + 29;
        let dy = spacingY / 6;
        let shiftX = (j % 2) * (spacingX / 2);
        let count = j % 2 == 1 ? pinCount + 1 : pinCount; //count of braid
        if (j % 2 == 0) {
          let startx1 = startX - (spacingX / 4) - 1;
          let startx2 = startX - (spacingX / 4) + 9;
          let startx3 = startX + (count - 1) * spacingX + 4;
          let startx4 = startX + (count - 1) * spacingX + 14;
          let starty1 = startY + j * spacingY - dy;
          let endy1 = startY + (j+1) * spacingY + dy;
          if (j == 0) {
            starty1 = starty1 + dy + dy;
          }
          if (j == rowCount) {
            endy1 = endy1 - dy - dy;
          }

          //Draws the 4 parallel top and bottom threads
          ctx.beginPath();
          ctx.moveTo(startx1, starty1);
          ctx.lineTo(startx1, endy1);

          // Draw the Path
          ctx.strokeStyle = 'green';
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(startx2, starty1);
          ctx.lineTo(startx2, endy1);

          // Draw the Path
          ctx.strokeStyle = 'green';
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(startx3, starty1);
          ctx.lineTo(startx3, endy1);

          // Draw the Path
          ctx.strokeStyle = 'pink';
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(startx4, starty1);
          ctx.lineTo(startx4, endy1);

          // Draw the Path
          ctx.strokeStyle = 'pink';
          ctx.stroke();
          //4 parallel bottom and top lines drawn for all pins.

        }
        for (let i = 0; i < count - 1; i++) {
            let x = startX + i * spacingX - shiftX;
            let y = startY + j * spacingY;
            braid = [];
            for (let k = 0  ; k < 2; k++) {
                const r = Math.floor(Math.random() * 4);
                if (r == 0) {
                braid.push(-1);
                } else if (r == 1) {
                braid.push(2);
                } else if (r == 2) {
                braid.push(-3);
                } else {
                braid.push([-1, -3]);
                }
            }
            //draws the braids
            drawBraid([x, y], braid);
            let ory = spacingY / braid.length - spacingY/6;
            let nx = spacingX / 6;
            let op = 0.05;


            if (!(j%2 == 1 && (i == 0 || i == count - 2) ) && j != rowCount) {
              let startXPos = x + nx + 4
              let startYPos = y + spacingY - spacingY/6;
              let endXPos = x + 4 + op;
              let endYPos = y + spacingY + spacingY/6;

              ctx.beginPath();
              ctx.moveTo(startXPos, startYPos);
              ctx.lineTo(endXPos, endYPos);

              // Draw the Path
              ctx.strokeStyle = 'black';
              ctx.stroke();

              let startXPos2 = x + nx + 14
              let startYPos2 = y + spacingY - spacingY/6;
              let endXPos2 = x + 14 + op;
              let endYPos2 = y + spacingY + spacingY/6;

              ctx.beginPath();
              ctx.moveTo(startXPos2, startYPos2);
              ctx.lineTo(endXPos2, endYPos2);

              // Draw the Path
              ctx.strokeStyle = 'black';
              ctx.stroke();

              let startXPos3 = x + nx + 24
              let startYPos3 = y + spacingY - spacingY/6;
              let endXPos3 = x + nx + 34 - op;
              let endYPos3 = y + spacingY + spacingY/6;

              ctx.beginPath();
              ctx.moveTo(startXPos3, startYPos3);
              ctx.lineTo(endXPos3, endYPos3);

              // Draw the Path
              ctx.strokeStyle = 'red';
              ctx.stroke();

              let startXPos4 = x + nx + 34
              let startYPos4 = y + spacingY - spacingY/6;
              let endXPos4 = x + +nx + 44 - op;
              let endYPos4 = y + spacingY + spacingY/6;

              ctx.beginPath();
              ctx.moveTo(startXPos4, startYPos4);
              ctx.lineTo(endXPos4, endYPos4);

              // Draw the Path
              ctx.strokeStyle = 'red';
              ctx.stroke();

            } else if (i == count - 2 && j != rowCount) {
              let startXPos = x + nx + 4
              let startYPos = y + spacingY - spacingY/6;
              let endXPos = x + 4 + op;
              let endYPos = y + spacingY + spacingY/6;

              ctx.beginPath();
              ctx.moveTo(startXPos, startYPos);
              ctx.lineTo(endXPos, endYPos);

              // Draw the Path
              ctx.strokeStyle = 'red';
              ctx.stroke();

              let startXPos2 = x + nx + 14
              let startYPos2 = y + spacingY - spacingY/6;
              let endXPos2 = x + 14 + op;
              let endYPos2 = y + spacingY + spacingY/6;

              ctx.beginPath();
              ctx.moveTo(startXPos2, startYPos2);
              ctx.lineTo(endXPos2, endYPos2);

              // Draw the Path
              ctx.strokeStyle = 'red';
              ctx.stroke();
            } else if (i == 0 && j != rowCount) {
              let startXPos3 = x + nx + 24
              let startYPos3 = y + spacingY - spacingY/6;
              let endXPos3 = x + nx + 34 - op;
              let endYPos3 = y + spacingY + spacingY/6;

              ctx.beginPath();
              ctx.moveTo(startXPos3, startYPos3);
              ctx.lineTo(endXPos3, endYPos3);

              // Draw the Path
              ctx.strokeStyle = 'red';
              ctx.stroke();

              let startXPos4 = x + nx + 34
              let startYPos4 = y + spacingY - spacingY/6;
              let endXPos4 = x + +nx + 44 - op;
              let endYPos4 = y + spacingY + spacingY/6;

              ctx.beginPath();
              ctx.moveTo(startXPos4, startYPos4);
              ctx.lineTo(endXPos4, endYPos4);

              // Draw the Path
              ctx.strokeStyle = 'red';
              ctx.stroke();
            }
        }
    }
}
};
  </script>
</body>
</html>
